\documentclass[10pt,a4paper]{article}

\usepackage[margin=3cm]{geometry}
\usepackage[UKenglish]{babel}
\usepackage{enumitem}
\usepackage{calc}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage[table]{xcolor}
\usepackage{float}
\usepackage{longtable}
\usepackage{parskip}
\usepackage{soul}
\usepackage[small,compact]{titlesec} 

\definecolor{titleColor}{RGB}{138,201,242}
\pagestyle{fancy}
\lhead{T Davies, A Fahie, A Fairbairn, A Free, J Mansfield, R Tucker, M Walker}
\chead{}
\rhead{GPIG-C}
\cfoot{\vspace{-0.6cm} \thepage}

\setlist{nolistsep} % Reduces lots of white space around lists

\renewcommand{\headrulewidth}{0.4pt} % Add rules below header
\renewcommand*{\thefootnote}{\fnsymbol{footnote}}

\begin{document}

\input{title}

\section{Introduction}

\section{Glossary}

\begin{description}
	\item[HUMS] Health and usage monitoring system(s).
	\item[Customer] Thales. 
	\item[Consumer] The recipient organisation of the system.
	\item[(End) User] An individual or organisation using the system.
	\item[Client] A piece of computer hardware or software which accesses a
	              service made available by the HUMS system.
	\item[The System] The HUMS we are designing and developing.
	\item[Event] A point of interest flagged up by an analysis system, which
	             may result in a notification.
	\item[Data input client] Anything that provides data to the HUMS through
	                         the input interface.
	\item[Data output client] Anything that receives data from the HUMS
	                          through the reporting or notification interfaces.
	\item[Notification] A message sent by the system as a result of an event
	                    being fired.
	\item[Report] A message sent by the system as a result of a request from a
	              user. 
	\item[HUMS Instance] One installation or occurrence of the system for a
	                     specific consumer.
\end{description}

\section{Requirements Refinement}

\section{System Architecture}
\subsection{Quality Attributes}
Quality attributes are defined in order to ensure the architectural decisions made when 
creating the system architecture not only provide the required functionality,
but also produce a system meeting the expectations of all stakeholders. For example the 
system may be expected to meet certain security standards or availability levels. 
Explicitly defining these quality attributes before concretely designing a system allows for 
the correct tactics and patterns to be adopted in order to maximise the utility of important 
qualities.

When examining the HUMS non-functional requirements the following system quality 
attributes were identified:
	\begin{center}
	\textit{
		Availability, Performance, Modifiability, Security, Testability, Usability}
	\end{center}
Of these availability, performance, security and usability can be observed and measured, 
the others are unobservable however steps can still be taken to maximise their utility.
%Maybe go into more detail if space

Availability defines how ready the system is to be used, and is normally the percentage of 
downtime over a specified timeframe. The desired utility of the quality attribute within the HUMS, as defined by the non functional requirements, is  99.9\% per month. Since lack of 
availability is often linked to faults occurring, fault detection and recovery tactics, such as 
use of runtime exceptions, redundancy through backups and transactions, could be 
employed in order to achieve the desired level of availability. 

The performance of a system is normally measured by its latency and throughput. The 
HUMS is required to dispatch notifications through the notification generator after events 
have been triggered by the analysis controller, with a latency less than 5ms, the system is 
also required to be able to support multiple data output clients. Tactics such as reducing overhead though careful use of data structures and prioritising events can help reduce latency, at 
least for the most important events, defined by the end user. It may also be possible to 
add concurrency, such that multiple notification threads are used when demand for 
notifications and reports are high, reducing the bottleneck created at the notification 
generator.

Modifiability is one of the most important qualities of the HUMS, though not measurable, 
lack of modifiability can increase the cost and time taken to complete the project. The 
HUMS will initially be built to tackle a single domain, software, however, will in the future 
be required to work on embedded systems, mechanical systems, electrical systems and 
even people. In order to ensure these changes are as efficient as possible the initial system 
must be modifiable. Tactics that can be used to increase the modifiability of the system include using small modules within the system, decreasing the coupling between those modules and increasing the cohesion. In order to achieve low coupling  the HUMS uses interfaces between modules and restricts dependencies, such that the majority of modules can be swapped out without large changes to the overall system.

\subsection{System Views}
When designing the HUMS we identified four different views of of the system which must be documented:
\begin{description}
\item[Module View] The required software modules and relationships between them at a high level.
\item[Behavioural View] The flow of data and dynamic actions within the system.
\item[Deployment View] How modules are geographically positioned.
\item[Conceptual View] Class Diagrams, showing a concrete implementation of the functionality.
\end{description}

\subsection{Module View}
Having determined the quality attributes of the HUMS and the tactics which can be employed in order to achieve a high utility of these qualities a conceptual view can be formed. The conceptual diagram shown in figure \hl{XXX} depicts the modules of the HUMS and the interactions between these modules at a high level.

%%%Input Diagram WITH KEY
\begin{description}
\item[Data Emitter]  Sends data to the system core in a standard format, may be included within the HUMS or created by the end user.
\item[Data Input Layer] Receives data from a data emitter and sends it to the data abstraction layer. Alerts the analysis controller that new data was received.
\item[Data Abstraction Layer] Handles all interaction with the database, such that if the database was to be altered, only this layer would need to change.
\item[Analysis Controller] Alert the analysis engines when new data has arrived, pulling the required data from the data abstraction layer. If an analysis engine determines an event has occurred within the data then the analysis controller forwards that event to the notification generator
 \item[Analysis Engine] Analyses the data looking for trends, it a trend is found an event is returned to the analysis controller. Analysis engines may be included in the HUMS or created by the end user.
 \item[Notification Generator] Receives events from the analysis controller, defines an abstract notification and sends it to the appropriate notification engine.
 \item[Notification Engine] Receives an abstract notification from the notification generator and creates a concrete notification, for example an email or triggering a change in system behaviour. Notification engines may be included in the HUMS or created by the end user.
  \item[Reports Engine] Pulls data from the data abstraction layer and formats it into a report, for example a PDF or graph. Reports engines may be included in the HUMS or created by the end user.
\end{description}

\subsection{Behavioural View}
The module view shows how modules of the system are connected, however, does not fully represent the interactions between components and the dynamic actions of the system.
A behavioural view can be used to detail this information, showing the flow of data and events within the HUMS. Figure \hl{XXX} shows the behavioural model of the HUMS, detailing how the HUMS goes from receiving data from a data emitter to generating a notification.
%%Input Diagram WITH KEY

\subsection{Deployment View}
With view to deployment the HUMS needs to be tailorable, the core system may be running on the same hardware as the data emitter, it may also be geographically distant. Engines may all be on separate machines or may all be together. Figures \hl{XXX and XXX} show the most main scenarios for deployment of the HUMS, with a view that if the system architecture can perform under these situations, then it can perform under all others.

\hl{We also chose to look at deploying the system as a service....}
%% TODO talk about admin centre shizzle

\subsection{Conceptual View}
%%Class diagrams WITH KEYS

\section{Interim Prototype Implementation}

\subsection{Technologies}
We chose to develop the core of the HUMS prototype using Java, this does restrict its use, as the JVM is required, however, at this stage we do not see this as a problem since the underlying architecture of the system is transferable across languages.
All members of our team were familiar with the Java programming language and thus no time was spent having to learn or teach a new language. 
We did not impose a language restriction when developing the data emitter and various engines as the data being passed between them and the core is language independent, meaning end users are free, even with the prototype, to implement engines in any language they see fit. For the prototype we used Java and \hl{XXX} when creating the engines, languages team members are familiar with, allowing us to show off the versatility of the system.
We chose to use Google App Engine to host the database for the prototype, again wanting to show the versatility of the system, and how easily it can easily incorporate popular technologies. The prototype could easily be extended to work with other database technologies simply by implementing an interface within the data abstraction layer.

We created a prototype admin centre to show how the HUMS could be run as a service, allowing users to integrate their system, viewing and editing it online. The admin centre was developed using HTML, JavaScript and CSS in order to create a prototype realistically simulating the required behaviour.

We used Git for version control, allowing the entire team to contribute to the project simultaneously, and Google Docs for sharing notes, plans and meeting minutes when designing the prototype.
\subsection{Current Functionality}

\subsection{Testing}

\subsection{Evaluation on Test Application}

\section{Team Structure}

\section{Risk register}

A risk assessment has been performed as part of the initial report to ensure the
team is aware of any problems which could later arise, and to provide a guide as
to how to react when such problems occur. The hazards (risks) have been
identified and classified based upon team members' past experiences in similar
projects and group discussion. The areas these hazards impact were then
analysed, as well as the probability of occurrence. These are then weighted so
that we can identify the risks which are likely to have the greatest detrimental
effect on the project. The likelihood score (LS), impact score (IS) and risk matrix score 
(RS) are
listed in the table below.

\input{risk-register}

The likelihood score defines probability of something occurring. Utilising
\textit{Kents Words of Estimative Probability}\cite{kent1966strategic}, with
`certain' weighted $7$ and `impossible' weighted $1$.

\input{riskass-table}
\input{risklevel-table}

\section{Customer communication}

\vfill
\bibliography{report-refs}
\bibliographystyle{IEEEtran}
\end{document}
